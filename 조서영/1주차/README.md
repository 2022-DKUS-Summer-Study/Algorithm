# 1주차 과제

강의 번호: 알고리즘
유형: 스터디
작성일시: 2022년 7월 7일 오후 11:38

## 13397, 구간 나누기 2, Gold 4

### 문제

[https://www.acmicpc.net/problem/13397](https://www.acmicpc.net/problem/13397)

N개의 수로 이루어진 1차원 배열이 있다. 이 배열을 M개 이하의 구간으로 나누어서 구간의 점수의 최댓값을 최소로 하려고 한다. 구간은 다음과 같은 조건을 만족해야 한다.

1. 하나의 구간은 하나 이상의 연속된 수들로 이루어져 있다.
2. 배열의 각 수는 모두 하나의 구간에 포함되어 있어야 한다.

구간의 점수란 구간에 속한 수의 최댓값과 최솟값의 차이이다.

예를 들어, 배열이 [1, 5, 4, 6, 2, 1, 3, 7] 이고, M = 3인 경우가 있다.

이때, [1, 5], [4, 6, 2], [1, 3, 7]로 구간을 나누면 각 구간의 점수는 4, 4, 6점이 된다. 이때, 최댓값은 6점이다.

만약, [1, 5, 4], [6, 2, 1], [3, 7]로 구간을 나누었다면, 각 구간의 점수는 4, 5, 4점이 되고, 이때 최댓값은 5점이 된다.

두 경우 중에서 최댓값이 최소인 것은 5점인 것이고, 5점보다 최댓값을 작게 만드는 방법은 없다.

배열과 M이 주어졌을 때, 구간의 점수의 최댓값의 최솟값을 구하는 프로그램을 작성하시오.

### 풀이

최댓값의 최솟값을 구하는 문제로, 최적화 문제를 결정 문제로 바꾸는 과정이 필요하다.

- 최적화 문제: N개의 수로 이루어진 1차원 배열을 M개 이하의 구간으로 나눠 구간의 점수의 최댓값을 최소로 하는 것
- 결정 문제: N개의 수로 이루어진 1차원 배열을 구간을 나눴을 때, 해당 구간의 최댓값이 기준값(mid)보다 작은 구간의 개수가 M개 보다 작은가를 판별하는 것

```python
#solve: 해당 구간의 최댓값이 기준값(mid)값보다 큰 구간의 개수를 반환
def solve(mid):
	cnt=1
	minV=INF 
	maxV=-INF
	for i in range(len(S)):
		minV=min(minV, S[i])
		maxV=max(maxV, S[i])
		
		if maxV-minV>mid:
			cnt+=1
			minV=S[i]
			maxV=S[i]
	
	return cnt

#이분탐색을 이용
high=max(S)
low=0
while low<high:
	mid=(high+low)//2

	if solve(mid)>m:
		high=mid
	else:
		low=mid+1

print(high)
```

# 2470, 두 용액, Gold 5

### 문제

KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.

예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.

### 풀이

1. 리스트(S)를 오름차순으로 정렬한다.
2. high=len(S)-1, low=0로 놓고(highV=S[high], lowV=S[low]) 값을 더해 용액의 특성값을 구한다.
3. 특성값이 0이 기존의 특성값의 최솟값보다 작다면 특성값과 result를 갱신한다.
4. 특성값이 0이라면 종료, 0보다 크면 high값을 1줄이고, 0보다 작으면 low값을 1늘려 탐색을 계속한다.

## 1920, 수 찾기, Silver 4

### 문제

N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

### 풀이

단순한 이분탐색을 이용해 찾는 문제이다. 이분탐색을 통해 탐색하다 정답값을 찾으면 1을 return하고 이분탐색이 종료되었음에도 정답값을 찾지 못하면 0을 return 한다.

## 10816, 숫자카드 2, Silver 4

### 문제

숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.

### 풀이

target값의 upper_bound와 target값의 lower_bound값을 찾아 그 차이를 구한다.

```python
def search_upperbound(S, target):
    high=len(S)
    low=0
    while low<high:
        mid=(high+low)//2
        
        if S[mid]<=target:
            low=mid+1
        elif S[mid]>target:
            high=mid
    
    return high

def search_lowerbound(S, target):
    high=len(S)
    low=0
    while low<high:
        mid=(high+low)//2
        
        if S[mid]>=target:
            high=mid
        elif S[mid]<target:
            low=mid+1
    
    return low
```

![image](https://user-images.githubusercontent.com/74875490/178016675-51cc0057-4b6c-493b-a50b-bade8d348017.png)

다음과 같이 target값이 3이면 high는 5, low는 3이 됨으로써 3의 개수는 2임을 알 수 있다.