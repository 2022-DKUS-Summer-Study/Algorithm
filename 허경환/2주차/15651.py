#15651 n과m(3)

"""
시간복잡도 계산

dfs(x)에서
if ~: 구문의 연산최대횟수 = 2m+2
else: 구문의 연산최대횟수 = 3n+n*T(x+1)


T(x) = 3n + n*(3n + n*T(x+1))
     = 3n + n*(3n + n*(3n + n*T(x+2)))
     ...
     = 3n + n*(3n + n*(3n + n*(.....(3n+n*T(m+1)))))

여기서 n의 최고차항만 남기면
T(x) = (2m+5)n^m

결국 시간복잡도는 O(n^m)이다.
"""


# 입력
n, m = map(int, input().split())

# 수열을 저장할 리스트
arr = [0] * (m + 1)


# dfs 구현
def dfs(x):
    # 만약 수열의 길이가 m이라면 -> 연산 최대횟수 = 2m+2
    if x == m + 1:
        for i in arr[1:]:
            print(i, end=' ')
        print()
    # 만약 수열의 길이가 m이 아니라면 -> 연산 최대횟수 = 3n+T(x+1)
    else:
        # 1~n까지 반복하며 해당 숫자를 수열에 사용
        for i in range(1, n + 1):
            # 수열리스트에 숫자 저장
            arr[x] = i
            # 재귀함수 호출로 자식노드로 이동
            dfs(x + 1)
            # 수열리스트에 숫자 제거
            arr[x] = 0


# dfs 실행 - 인풋값은 수열의 인덱스
dfs(1)
