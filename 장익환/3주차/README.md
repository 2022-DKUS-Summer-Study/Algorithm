# 3주차 과제

## [1074번: Z (acmicpc.net)](https://www.acmicpc.net/problem/1074)

- 이 문제에서는 $2^N \times 2^N$ 크기의 2차원 배열을 주어진 규칙에 따라서 방문할 때, r행 c열을 몇 번째로 방문하는지 출력해야 한다.
- 2차원 배열을 방문하는 순서는 재귀로 구현할 수 있다. 따라서 재귀를 이용한 분할정복을 통해서 문제를 해결할 수 있다.
- find 함수는 r행 c열이 몇 번째로 방문되는지 구해서 출력한다.
    - 우선 방문해야 할 2차원 배열의 너비를 입력 받는다.
    - 크기가 $width \times width$ 인 배열을 4등분해서, r행 c열이 속하는 영역을 결정한다.
    - 너비가 2보다 크면, 재귀를 통해서  r행 c열이 그 영역을 4등분한 것 중 어느 부분에 속하는지 결정한다.
    - 너비가 2가 되면, r행 c열의 범위를 최대로 좁힌 것이다. $2 \times 2$ 크기의 배열에서 Z 모양으로 원소를 방문해서 몇 번째로 방문했는지 출력하면 된다.

- 이 알고리즘의 시간 복잡도는 $T(N) = O(N)$이다.
    - 이 알고리즘의 입력을 N이라고 하자
    - find함수의 시간을 f(N)이라고 하자.
        - 영역을 결정하는 시간을 $c$라고 하고, k=1일때 연산을 수행하는 시간을 $l$이라고 하자.
        - 입력 값인 width는 함수의 시작 부분에서  $2^i$이고, 재귀호출 전에 2로 나뉜다. 재귀는 width가 2가 될 때까지 계속된다.
        - 이를  width의 지수 i의 입장으로 생각하면, 입력 값 i는 재귀 호출 전에 1씩 감소되고, i가 1이 되면 재귀 호출이 종료된다.
        - 따라서 f(N)은 다음과 같다.
        - $f(N) = f(N-1) + c (N>1)$ 또는 $k (N =1)$
        - $f(N) = (N-1) \times c + l$
        - 따라서 $f(N) = O(N)$이다.
    - 한편 width를 구하는데 걸리는 시간은  $O(N)$이다.
    - 따라서 전체 걸리는 시간 $T(N)$이라고 하면
    - $T(N) = O(N) + O(N) = O(N)$이다.

## [5904번: Moo 게임 (acmicpc.net)](https://www.acmicpc.net/problem/5904)

- 이 문제에서는 주어진 규칙에 따라 moo 수열을 만들 때 N번째 문자가 무엇인지 출력해야 한다.
- 무식한 방법으로 해결한다면, moo 수열을 직접 만들어서 N번째 문자가 무엇인지 알아낼 수 것이다. 하지만 메모리 제한을 넘어설 수 있으므로 이 방법은 구현하지 않는 것이 좋다.
- moo 수열은 재귀적으로 정의되기 때문에, 재귀를 이용한 분할 정복으로 해결할 수 있다.
- 우선 find 함수를 호출하기 전에, N번째 문자가 존재하면서 길이가 가장 짧은 수열 S(k)의 길이와 이 때의 k 값을 구해야 한다.
- find함수는 S(k)에서 i번째 문자가 무엇인지 구한다.
    - 이 함수는 i번째 문자가 S(k)에서 어느 부분에 속하는지 확인한다.
    - 앞이나 뒤에 있는 S(k-1) 부분에 i번째 문자가 속한다면, 재귀 호출을 통해서 구한다.
    - 만약 중간에 있는 k + 3개의 문자 중 하나에 속하면, 바로 구해서 출력한다.
    - 최악의 경우 재귀 호출은 k=0이 될 때까지 이어진다. k = 0이면 해당하는 문자를 바로 구할 수 있다.
    
- 이 알고리즘의 복잡도는 대략 $T(N) = O(N)$으로 추정된다.
    - find 함수에서 N번째 문자가 S(k)의 어느 부분에 속하는 지에 따라 재귀 호출의 깊이와 수행 시간이 달라진다.
    - find 함수의 시간을 f(k)라고 하면 다음과 같다.
        - $f(k) = f(k-1) + c$ (N이 S(k-1)에 속함, k > 0)
        - 또는  $l$ (N이 S(k)의 중간에 있는 K+3개의 문자에 속함, k > 0)
        - 또는  $m$  (k <= 0)
    - 정확한 시간 복잡도는 구하기 힘들기 때문에 재귀 호출의 깊이가 k - 1이라고 하자.
        - 그러면 $f(k) < (k - 1) \times c + m$
        - 따라서 $f(k) = O(k)$이다.
    - find 함수를 실행하기 전에 k와 size를 미리 구해야 하는데, 이때 걸리는 시간도 정확히 구하기는 어려워 보인다.
        - 최악의 경우, $W(N) <= N$이니 $W(N) = O(N)$이다.
        - 이때 $k = N$이다.
    - 따라서 전체 시간 복잡도 T(N)은 다음과 같다.
        - $T(N) = O(N) + O(k) = O(2 \times N) = O(N)$
        - 하지만 실제 시간 복잡도는 이보다 더 작을 것이다.