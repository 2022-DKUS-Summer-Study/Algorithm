# 5주차 과제

## [1541번: 잃어버린 괄호 (acmicpc.net)](https://www.acmicpc.net/problem/1541)

주어진 식에서 괄호를 적절히 쳐서 식의 최솟값을 구해야 한다.

입력되는 식은 숫자와 +,- 연산자로 구성되며 최대 길이는 50이다. 숫자는 최대 5 자리 수이다.

- 식에 존재하는 연산자가 모두 + 라면, 식의 최대 값은 99999 * 50을 절대 넘지 못한다.
- 따라서 int 형 변수에 결과를 저장할 수 있다.

탐욕법을 이용해서 문제를 풀어보겠다.

- 식의 최솟값을 구하려면 다음과 같이 계산해야 한다.
    - 처음에 누적합은 0이라고 한다.
    - 식의 앞에서 시작해서 연산자를 하나씩 방문한다.
    - 아직 - 연산자를 만나지 못했다면, 연산자의 뒤에 나오는 수를 누적합에 더한다.
    - - 연산자를 만났다면, 이후에 나오는 수를 누적합에서 뺀다.
    - 이렇게 구한 누적합이 바로 식의 최솟값이다.
    

식의 길이를 N이라고 했을 때, 알고리즘의 시간복잡도는 $O(N)$이다.

- 식의 값의 최소를 구하는 get_min 함수에서 for문을 통해서 문자열의 문자를 하나씩 순회한다.
- 이때 for문의 복잡도가  $O(N)$이다.
- 나머지 연산은 상수시간이 걸리므로 무시해도 된다.
- 그러므로 시간 복잡도는 $O(N)$이다.

## [1931번: 회의실 배정 (acmicpc.net)](https://www.acmicpc.net/problem/1931)

이 문제는 회의실에 배정할 수 있는 회의의 최대 개수를 구하는 것이다.

탐욕법을 이용해서 문제를 해결해보았다.

- 배정할 수 있는 회의의 수를 최대로 만드는 방법은 종료 시간이 제일 빠른 것부터 선택해나가는 것이다.
- 종료 시간이 빠른 회의를 우선적으로 선택해서, 회의들이 겹치지 않도록 배정한다.
- 이렇게 하면 최대한 많은 회의를 배정할 수 있다.

회의의 수를 N이라고 할 때, 이 알고리즘의 시간복잡도는 $O( N \log N)$이다.

- 답을 구하는 get_max함수를 호출하기 전에 배열을 정렬해야 한다.
- 이때 배열을 정렬하기 위한 시간 복잡도는 $O(N \log N)$이다.
- get_max 함수에서는 배열에 있는 N개의 원소를 순회하면서 배정할 수 있는 회의의 수를 구한다. 이때 시간 복잡도는 $O(N)$이다.
- 따라서 알고리즘의 시간 복잡도는 $O(N \log N) + O(N) = O(N \log N)$ 이다.

## [13975번: 파일 합치기 3 (acmicpc.net)](https://www.acmicpc.net/problem/13975)

이 문제는 파일을 하나로 합치는데 드는 비용의 최솟값을 구하는 것이다.

탐욕법을 이용해서 문제를 해결해보았다.

- 파일을 하나로 합치는 비용을 최소화하려면 매번 두 개의 파일을 합칠 때마다 비용이 최소이어야 한다.
- 따라서 매번 크기가 가장 작은 두 파일을 선택해서 합쳐나가야 한다.

답을 구하기 위해서, 최소 비용을 구하는 get_min_cost 함수를 구현했다.  

- 이 함수에서는 파일의 크기들을 우선순위 큐에 저장한다.
- 그 다음에 파일을 합치면서 최소 비용을 구한다.
    - 우선순위 큐에서 가장 작은 원소 2개를 꺼낸다. 그 다음에 두 수를 더한 값을 다시 우선순위 큐에 넣는다.
    - 이러한 작업을 우선순위 큐에 원소 하나만 남을 때까지 반복한다.
- 두 수를 합칠 때마다 그 합을 누적해서 더해야 하는데, 나중에 누적된 값이 답이 된다.
- 이 문제에서는 값의 범위에 주의해야 한다. 파일의 수가 최대 100만 개 존재할 수 있고, 파일의 크기는 10000을 넘지 않기 때문에,
- 전체 비용은 int형 변수가 아니라 long long형 변수에 저장하는 것이 안전하다.

파일의 수가 N일 때, 이 알고리즘의 시간 복잡도는 $O( N \log N)$이다.

- 배열에 저장된 파일의 크기를 우선순위 큐에 저장해야 하는데, 이 작업은 대략 $O(N \log N)$의 시간이 걸린다.
- 그 다음에 우선순위 큐에서 2개의 원소를 꺼내고, 1개의 원소를 넣는다.
    - 이러한 작업을 한번 하는데 대략 $O(\log N)$의 시간이 걸린다.
    - 이 작업을 N-1번 반복하므로 전체 시간은 대략 $O( N \log N)$이다.
- 따라서 이 알고리즘의 시간복잡도는 $O( N \log N) + O( N \log N) = O( N \log N)$이다.