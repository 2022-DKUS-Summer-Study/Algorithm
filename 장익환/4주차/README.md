# 4주차 과제 (1)

## [1010번: 다리 놓기 (acmicpc.net)](https://www.acmicpc.net/problem/1010)

- 이 문제는 서쪽에 있는 N개의 사이트와 동쪽에 있는 M개의 사이트 사이를 잇는 N개의 다리를 놓는 것이다. 이때 다리는 서로 교차하지 않아야 한다.
- 이 문제는 동적계획법을 이용해서 해결할 수 있었다.
- calc_case라는 함수는 다리를 놓는 경우의 수를 구한다.
    - N개의 사이트를 밑에서부터 차례로 각각 {$a_1, a_2, ..., a_n$} 라고 하고, M개의  사이트를 밑에서부터 차례로 각각 {$b_1, b_2, ..., b_m$}라고 하자.
    - 이 함수는 $a_n$에서 $b_m$을 잇는 다리를 놓을 지 여부를 결정한다.
    - 만약 이를 선택한다면, 다음에 놓을 다리의 수는 n-1개이고 선택할 수 있는 사이트는 M-1개가 된다.
    - 만약 이를 선택하지 않는다면, 다음에 놓을 다리의 수는 n개이고 선택할 수 있는 사이트는 M-1개가 된다.
    - 따라서 calc_case 함수의 결과 값은 다음과 같다.
        - calc_case(n, m) = calc_case(n - 1, m - 1) + calc_case(n , m - 1)
    - 기저 사례는 n > m일 때와 n = 1일 때, 그리고 n = m일 때이다.
        - n > m이면 다리를 놓을 수 없다.
        - n = 1이면 서쪽에 1개의 사이트만 있으므로 동쪽에 있는 어느 부분과 연결해도 상관 없다. 따라서 이 경우는 m가지 이다.
        - n = m이면 바로 대응되는 사이트끼리 다리를 놓으면 된다. 이 경우는 1가지이다.
- 중복되는 계산을 줄이기 위해서 메모이제이션을 이용했다.
    - memo배열은 이전에 구한 결과 값을 저장한다. 만약 이미 구한 값이면 함수는 배열에 저장된 값을 반환한다.

- 이 알고리즘의 시간복잡도는 $O(N \times M)$으로 추정된다.
    - calc_case 함수에서 기저 사례인 경우나 값을 이미 구한 경우라면 상수 시간이 걸린다. 그러므로 수행시간은 재귀에 의해서 직접 계산되는 문제들에 의해서 결정된다.
    - calc_case(N, M)에서 부분 문제의 개수의 상한은 $O(N \times M)$이다.
    - 따라서 시간 복잡도는 $O(N \times M)$이다.
    - 다만 이보다 더 작은 상한이 존재할 것이다.
        - n = m인 기저 사례가 존재하며, 실제로 계산되는 문제의 수는 그 상한 보다 더 적기 때문이다.

## [11726번: 2×n 타일링 (acmicpc.net)](https://www.acmicpc.net/problem/11726)

- 이 문제에서는 2 x N 크기의 직사각형을 1 x 2 타일과 2 x 1타일로 채우는 경우의 수를 구하는 것이다.
- 이 문제도 동적 계획법을 통해서 시간을 단축할 수 있었다.
- 편의상 N을 직사각형의 너비라고 하고, 직사각형에 같은 크기의 타일을 가로로 놓거나 세로로 놓을 수 있는 상황이라고 생각해보자.
    - 너비가 width인 직사각형의 왼쪽 부분부터 타일을 놓는다면, 가로로 놓는 경우와 세로로 놓는 경우 2가지 중 하나를 매번 선택해야 한다.
    - 타일을 세로로 놓으면, 남은 직사각형의 너비는 width - 1이고
    - 타일을 가로로 놓으면 수직으로 2개를 쌓아서 놓아야 한다. 따라서 남은 직사각형의 너비는 width - 2이다.
    - 다음 타일을 놓을 때마다 타일을 세로로 놓을지, 가로로 놓을지를 결정해야 한다.
- 함수 find(width)는 너비가 width인 직사각형에 타일을 놓는 경우의 수를 반환한다.
    - 이때 다음과 같은 식이 성립한다.
    - find(width) = find(width - 1) + find(width - 2)
    - 직사각형의 맨 왼쪽에서 타일을 세로로 놓는 경우의 수와 가로로 놓는 경우의 수를 더해서 전체 경우의 수를 구하는 것이다.
- 이때 기저 사례는 width < 0일 때와 width = 0일 때이다.
    - width < 0이면, 직사각형의 크기를 넘어선 것으로 존재할 수 없는 경우이다. 따라서 0을 반환해야 한다.
    - width = 0이면, 직사각형을 모두 채운 것이다. 따라서 1을 반환한다.
- 중복되는 계산을 줄이기 위해서 메모이제이션을 이용했다.
    - 이미 구한 값은 memo 배열에 저장해서 다시 사용하도록 했다.
    
- 이 알고리즘의 시간복잡도는  $O(N)$이다.
    - find 함수에서 기저사례인 경우나 값을 이미 구한 경우라면 상수 시간에 해결이 가능하다. 그래서 재귀를 통해서 직접 계산되는 문제에 의해서 수행시간이 결정 될 것이다.
    - find(N)을 해결하기 위해서 find(N), … ,find(1)을 해결해야 하므로 find(N)이 계산해야 할 문제의 개수는 N개이다.
    - 따라서 시간 복잡도는 O(N)이다.