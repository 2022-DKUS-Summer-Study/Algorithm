# 6주차 과제

## [5052번: 전화번호 목록 (acmicpc.net)](https://www.acmicpc.net/problem/5052)

 

 이 문제는 전화번호 목록이 일관성을 유지하는지 판정하는 문제이다. 이때 일관성이 있다는 것은 어떤 전화번호가 다른 번호의 접두어가 아닌 것을 가리킨다.

 트라이를 이용해서 이 문제를 해결할 수 있었다.

- 일단 단순히 모든 문자열 서로 비교하는 것은 시간 제한을 초과할 가능성이 있기 때문에 다른 방법을 생각해보았다.
- 문자열 집합에서, 다른 문자열의 접두어가 되는 문자열을 찾아야 하니 트라이를 써보기로 했다.
- 문자열을 하나씩 트라이에 추가하면서 다른 문자의 접두어가 되는 문자열이 존재하는지 확인하면 된다.

TrieNode 클래스는 트라이를 구현한다.

- 이 클래스에서 is_consistent 메소드는 트라이에 새로운 문자열을 추가할 때 일관성이 유지되는지 확인한다.
    - 다음의 두 경우는 일관성이 유지되지 못하는 경우라고 판정한다.
    - 일단 새로운 문자열을 추가하는 과정에서 is_end가 true인 노드를 만난다면, 이미 접두어가 존재하는 경우이다.
    - 또한 새로운 문자열을 추가하는 과정에서 새로운 노드가 생성되지 않는다면, 현재 추가되는 문자열이 접두어인 경우이다.
- 이 메소드는 일관성이 유지된다면, true를 반환한다. 일관성이 유지되지 않는다면, false를 반환한다.

모든 문자열의 길이의 합을 $M$이라고 할 때, 이 알고리즘의 시간복잡도는 $O(M)$이다.

- 문제를 해결하기 위해 is_consistent 메소드를 이용해서 트라이를 구성해나간다.
- 접두어가 맨 마지막으로 트라이에 추가되는 최악의 경우에는 트라이를 구성하는 시간 복잡도와 같다.
- 따라서 최악의 경우에 시간 복잡도는 $O(M)$일 것이다.

## [16916번: 부분 문자열 (acmicpc.net)](https://www.acmicpc.net/problem/16916)

이 문제는 S와 P가 주어졌을 때, P가 S의 부분 문자열인지 판정하는 문제이다.

이 문제를 해결하기 위해서 KMP 알고리즘을 이용했다.

- S의 각 문자를 시작점으로 해서 P와 모든 문자가 같은지 차례로 확인하는 단순한 방법도 있지만, 문자열의 길이가 최대 100만이므로 시간초과가 발생할 수 있다.
- 그래서 문자열에서 부분 문자열이 존재하는지 판정하는 빠른 방법인 KMP 알고리즘을 이용했다.
- KMP 알고리즘을 이용해서 S 안에 P와 같은 패턴이 존재하는지 확인하고 판정하면 간단히 해결된다.

 

KMP알고리즘을 이용하기 위해서 kmp 함수와 get_fail 함수를 구현했다.

- get_fail 함수는 pi배열을 생성하는 함수이다.
- kmp 함수는 pi배열을 이용해서 문자열에서 찾는 패턴이 존재하는지 판정하는 함수이다.

S의 길이를 $N$, P의 길이를 $M$이라고 하면, 시간 복잡도는  $O(N + M)$이다. 

- KMP 알고리즘을 이용하기 때문이다.
- get_fail 함수는 $O(M)$의 시간이 걸리고, kmp 함수는 $O(N)$의 시간이 걸린다.
- 따라서 시간 복잡도는 $O(N + M)$이다.